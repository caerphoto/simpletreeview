# SimpleTreeView

A JavaScript checkbox tree control that leaves the styling up to you, so you can
customise it to fit your application without the hassle of overriding tons of
existing CSS rules.

Here’s an example one, randomly generated by the included `domspeedtest.html`
page and styled with rules in `domspeedtest.css`:

![simple tree view example](http://andyf.me/media/misc/simpletreeview-lorem-example.png)

You’re encouraged to explore the created HTML element structure and classnames
using your browser’s devtools. The elements, and classes applied to them, are
explained later on.

## Dependencies

STV requires [Underscore.js](http://underscorejs.org/), for various iteration
and array mapping functions ([lodash](https://lodash.com/) might also work), and
[jQuery](http://jquery.com/) for event handling and some DOM manipulation.

## Basic usage

Once the script is included in your page, you can get started like so:

```javascript
var tree = SimpleTreeView.create({
    data: {
        label: '<div class="root">Root node</div>',
        value: '*',
        children: [
            {
                label: 'Child 0',
                value: 'c0',
                children: [
                    { label: 'HelloWorld' },
                    { label: 'LoremIpsum' }
                ]
            },
            {
                label: '<a href="#">Child 1</a>',
                value: 'c1'
            }
        ]
    },
    initialSelection: [ 'c0' ],
    element: document.querySelector('#tree'),
    HTMLLabels: true
});

tree.render();
```

## Options

You can pass the following options when creating a tree:

- **data**: as described above, the actual data structure used to build and
  render the tree. Consists of an object with, at minimum, either a `label` or a
  `value` property. Can have a `children` property, a list of objects of this
  structure, to arbitrary nesting depth.

- **initialSelection**: a string or list of strings representing the values of
  nodes that should be set to selected initially.

- **element**: an HTML element into which you’d like to render the tree. You can
  use the tree without getting the DOM involved, but obviously it won’t be able
  to render unless you give it somewhere to go.

- **HTMLLabels**: set to `true` if you want to use HTML in node element labels;
  by default this is `false`, so labels are created as plain text.

## API

### Tree

Once you’ve created an instance of a tree, there are a number of methods you can
call on it:

- **setElement(*element*)**: tells the tree which HTML element to insert its
  rendered output into. TODO: when setElement() is called on an already rendered
  tree, move the tree to the new element.

- **getElement()**: returns the HTML element the tree is assigned to.

- **setData(*data*)**: replace the existing tree data structure with the new
  one.

- **getData()**: returns the data structure used to set up the tree, but
  including all the additional properties the tree uses, such as selection
  state.

- **copyData()**: returns a deep copy of the tree, limited to each node’s
  `label`, `value`, `parent`, `state` and `children` properties.

- **getSelectedNodes()**: returns a list of the current selected nodes. If a
  parent node is fully selected, only it will be returned, not all of its
  descendants.

- **getSelection()**: returns a list of strings representing the values of the
  currently selected nodes. Basically a convenient wrapper around
  `getSelectedNodes()`.

- **setSelection(*selection*)**: reset the current selection to the given value,
  which can be either a string representing a node value, or a list of strings.

- **nodeAt(*location*)**: gets the node at the given location, which must be an
  array of indices, starting with the root, into each subsequent node’s children
  list. For example, `[ 0, 0 ]` is the first child of the first child. Pass `[]`
  to return the root node (which is the same as calling `getData()`).

- **nodeWithValue(*value*)**: gets the (first) node whose `value` property matches the given value.

- **nodeWithId(*id*)**: each node has a unique ID, which is also attached to its
  associated DOM element via the `data-node-id` attribute. This can be useful
  for event handling.

- **render(*depth*)**: renders the tree in its element, optionally limited to
  the given nesting depth.

The tree has an input box (with class `stv-filter-input`) before its root
element that allows filtering/searching. Matching is case-insensitive, and done
against nodes’ labels and values.

If you don’t filter functionality, you can pass `filter: false` in the options
when creating a tree.

### Nodes

Nodes have a couple of methods you can call on them:

- **select()**: marks the node as selected, also cascading the effect as
  appropriate up and down the tree, and updating the affected nodes’ associated
  HTML element’s CSS classes.

- **deselect()**: the inverse of `select()`.

Nodes also have the following properties, all of which should be considered
**read-only**:

- **label**: the node’s label, as displayed on the rendered tree.

- **value**: an arbitrary value assigned to the node.

- **state**: one of `SimpleTreeView.UNSELECTED` (0), `SimpleTreeView.PARTIAL` (1)
  or `SimpleTreeView.SELECTED` (2).

- **parent**: a reference to the node’s parent, or `null` if the node is the root.

- **children**: a list of the node’s children. If the node has no children, the
  list will be empty.

- **tree**: a reference to the instance of SimpleTreeView the node belongs to.

- **id**: a unique ID in the form `STV_x` where `x` is a number.

- **elements**: contains a reference to each HTML element making up the rendered
  node, as detailed below. Obviously you should **be careful modifying these**,
  lest you confuse the tree.

## HTML elements and CSS classes

The element for the root node of the tree is a `div`, and all other nodes have
`li`s.  Both have the class `stv-node`; the root also has `stv-root-node` while
all others have `stv-child-node`.

A node’s ID is available on its element via the `data-node-id` attribute.

If a node has children, its element is also given a class of `stv-parent`,
otherwise it gets the class `stv-leaf`. This is useful for hiding the expander
as appropriate.

Each node’s `state` property is represented on its element by the classes
`stv-selected`, `stv-partially-selected` and `stv-unselected`.

A node does not itself keep track of whether its child list is expanded or not –
the classes `stv-expanded` and `stv-collapsed` are simply toggled on and off on
the node’s element instead.

When filtering is in progress, the root nodes gets the class `stv-filtering`
added to it, and any matching nodes get `stv-filter-match`. In addition, all
ancestors to matching nodes get `stv-filter-descendant-match`, to properly allow
hiding of non-matching nodes while keeping the branches containing matching
nodes visible. See **domspeedtest.html** for an example of how you could use
these classes.

Within the node `div` or `li` element there are the following, in this order:

- A `span` with class `stv-expander`: clicking this toggles the `stv-expanded`
  and `stv-collapsed` classes, as explained above.

- A `span` with class `stv-checkbox`: clicking this toggles the selection state
  of the node.

- A `label` with class `stv-label`: depending on whether you specify
  `HTMLLabels: true` or not when creating the tree, contains either an HTML text
  node representing the node’s `label` property, or the node’s `label` property
  inserted directly as HTML.

- A `ul` with class `stv-child-list`: container for the elements of the node’s
  children.
