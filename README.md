# SimpleTreeView

A JavaScript checkbox tree control that leaves the styling up to you, so you can
customise it to fit your application without the hassle of overriding tons of
existing CSS rules.

Here’s an example one, randomly generated by the included `domspeedtest.html`
page and styled with rules in `domspeedtest.css`:

![simple tree view example](http://andyf.me/media/misc/simpletreeview-lorem-example.png)

You’re encouraged to explore the created HTML element structure and classnames
using your browser’s devtools. The elements, and classes applied to them, are
explained later on.

## Dependencies

STV requires [Underscore.js](http://underscorejs.org/), for various iteration
and array mapping functions ([lodash](https://lodash.com/) might also work), and
[jQuery](http://jquery.com/) for event handling and some DOM manipulation.

## Basic usage

The main thing you need to supply the control is a tree data structure, since it
obviously won’t be much use without one. The tree should look something like
this:

```javascript
treeData = {
    label: 'Root node',
    value: '*',
    children: [
        {
            label: 'Child 0',
            value: 'c0',
            state: SimpleTreeView.SELECTED
        },
        {
            label: 'Child 1',
            value: 'c1'
            state: SimpleTreeView.UNSELECTED
        }
    ]
}
```

Most of these properties are optional, but you’ll need to supply, at minimum,
either a `label` or a `value`; whichever is missing will be copied from the
other (to simplify rendering).

To actually set up a tree, do the following:

```javascript
var tree = new SimpleTreeView({ data: treeData });
```

## Options

You can pass the following options when creating a tree:

- `data`: as described above, the actual data structure used to build and render
  the tree.
- `element`: an HTML element into which you’d like to render the tree. You can
  use the tree without getting the DOM involved, but obviously it won’t be able
  to render unless you give it somewhere to go.
- `HTMLLabels`: set to `true` if you want to use HTML in node element labels; by
  default this is `false`, so labels are created as plain text.

## API

Once you’ve created an instance of a tree, there are a number of methods you can
call on it:

- **setElement(*element*)**: tells the tree which HTML element to insert its
  rendered output into. TODO: when setElement() is called on an already rendered
  tree, move the tree to the new element.

- **getElement()**: returns the HTML element the tree is assigned to.

- **setData(*data*)**: replace the existing tree data structure with the new
  one.

- **getData()**: returns the data structure used to set up the tree, but
  including all the additional properties the tree uses, such as selection
  state.

- **copyData()**: returns a deep copy of the tree, limited to each node’s
  `label`, `value`, `parent`, `state` and `children` properties.

- **getSelectedNodes()**: returns a list of the current selected nodes. If a
  parent node is fully selected, only it will be returned, not all of its
  descendants.

- **getSelection()**: returns a list of strings representing the values of the
  currently selected nodes. Basically a convenient wrapper around
  `getSelectedNodes()`.

- **setSelection(*selection*)**: reset the current selection to the given value,
  which can be either a string representing a node value, or a list of strings.

- **nodeAt(*location*)**: gets the node at the given location, which must be an
  array of indices, starting with the root, into each subsequent node’s children
  list. For example, `[ 0, 0 ]` is the first child of the first child. Pass `[]`
  to return the root node (which is the same as calling `getData()`).

- **nodeWithValue(*value*)**: gets the (first) node whose `value` property matches the given value.

- **nodeWithId(*id*)**: each node has a unique ID, which is also attached to its
  associated DOM node via the `data-node-id` attribute. This can be useful for
  event handling.

- **render(*depth*)**: renders the tree in its element, optionally limited to
  the given nesting depth.

Nodes also have a couple of methods you can call on them:

- **select()**: marks the node as selected, also cascading the effect as
  appropriate up and down the tree, and updating the affected nodes’ associated
  HTML element’s CSS classes.

- **deselect()**: the inverse of `select()`.

A node’s selection state is represented by its `state` property, which is one of
`SimpleTreeView.UNSELECTED` (0), `SimpleTreeView.PARTIAL` (1) or
`SimpleTreeView.SELECTED` (2).

In addition, nodes have an `elements` property which contains a reference to
each HTML element making up the rendered node, as detailed below. Obviously you
should **be careful modifying this property**, lest you confuse the tree.

## HTML elements and CSS classes

The root node of the tree is a `div` element, and all other nodes are `li`s.
Both have the class `stv-node`; the root also has `stv-root-node` while all
others have `stv-child-node`.

If a node has children, its element is also given a class of `stv-parent`,
otherwise it has the class `stv-leaf`. This is useful for hiding the expander as
appropriate.

Each node’s `state` property is represented on its element by the classes
`stv-selected`, `stv-partially-selected` and `stv-unselected`.

A node does not itself keep track of whether its child list is expanded or not –
the classes `stv-expanded` and `stv-collapsed` are simply toggled on and off on
the node’s element instead.

Within the node `div` or `li` element there are the following:

- A `label` with class `stv-label`: depending on whether you specify
  `HTMLLabels: true` or not when creating the tree, contains either an HTML text
  node representing the node’s `label` property, or the node’s `label` property
  inserted directly as HTML.
- A `span` with class `stv-checkbox`: clicking this toggles the selection state
  of the node.
- A `span` with class `stv-expander`: clicking this toggles the `stv-expanded`
  and `stv-collapsed` classes, as explained above.
- A `ul` with class `stv-child-list`: container for the elements of the node’s
  children.
